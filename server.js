const fs = require('fs');
const path = require('path');
const LRU = require('lru-cache');
const express = require('express');
const favicon = require('serve-favicon');
const compression = require('compression');
const microcache = require('route-cache');
const resolve = file => path.resolve(__dirname, file);
const { createBundleRenderer } = require('vue-server-renderer');
const config = require('./config');

// 判断是否为正式环境
const isProd = process.env.NODE_ENV === 'production';
// 判断是否使用页面缓存
const useMicroCache = process.env.MICRO_CACHE !== 'false';
//服务信息
const serverInfo =
  `express/${require('express/package.json').version} ` +
  `vue-server-renderer/${require('vue-server-renderer/package.json').version}`;
console.log('serverInfo:   '+serverInfo);

const app = express();

//这个方法进行保留
const parseHTML = template => {
  const placeholder = '<!--head-->'
  const i = template.indexOf(placeholder)
  return {
    head: template.slice(0, i),
    tail: template.slice(i + placeholder.length)
  }
}
//这个方法进行保留
const parseMeta = (html, context) => {
  let obj = parseHTML(html);
  let head = obj.head;
  const title = context.title || '';
  const description = context.description || '';
  const keywords = context.keywords || '';
  head = head.replace(/(<title>)(.*?)(<\/title>)/, `$1${title}$3`)
  head = head.replace(/(<meta name=description content=")(.*?)(">)/, `$1${description}$3`)
  head = head.replace(/(<meta name=keywords content=")(.*?)(">)/, `$1${keywords}$3`)
  return head+obj.tail
}


//创建一个ssr
function createRenderer (bundle, options) {
  // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
  // renderToString: Function
  // renderToStream: Function
  return createBundleRenderer(bundle, Object.assign(options, {
    // for component caching  组件缓存
    cache: LRU({
      max: 1000,
      maxAge: 1000 * 60 * 15
    }),
    // this is only needed when vue-server-renderer is npm-linked
    basedir: resolve('./dist'),
    /*
       runInNewContext： recommended for performance  推荐我们这样做
    * 默认情况下，对于每次渲染，bundle renderer 将创建一个新的 V8 上下文并重新执行整个 bundle。这具有一些好处 -
    * 例如，应用程序代码与服务器进程隔离，我们无需担心文档中提到的状态单例问题。然而，这种模式有一些相当大的性能开销，
    * 因为重新创建上下文并执行整个 bundle 还是相当昂贵的，特别是当应用很大的时候。
    * */
    runInNewContext: false
  }))
}

let renderer,readyPromise;
// 嵌套的模板文件
const templatePath = resolve('./src/index.template.html');
if (isProd) {
  //生产：创建使用模板服务器渲染和建立服务器包。
  // In production: create server renderer using template and built server bundle.
  // The server bundle is generated by vue-ssr-webpack-plugin.
  const template = fs.readFileSync(templatePath, 'utf-8');
  const bundle = require('./dist/vue-ssr-server-bundle.json');
  // The client manifests are optional, but it allows the renderer
  // to automatically infer preload/prefetch links and directly add <script>
  //自动推断预加载/预取链接并直接添加<脚本>
  // tags for any async chunks used during render, avoiding waterfall requests.
  //任何异步块使用在渲染标签，避免瀑布的请求。
  const clientManifest = require('./dist/vue-ssr-client-manifest.json')
  renderer = createRenderer(bundle, {
    template,
    clientManifest
  })
} else {
  // In development: setup the dev server with watch and hot-reload,
  //在开发中：用监听和热重新加载来设置开发服务器，
  // and create a new renderer on bundle / index template update.
  readyPromise = require('./build/setup-dev-server')(
    app,
    templatePath,
    (bundle, options) => {
      renderer = createRenderer(bundle, options)
    }
  )
}


//静态资源托管文件
const serve = (path, cache) => express.static(resolve(path), {
  maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0
})

app.use(compression({ threshold: 0 })); //默认的过滤器函数使用可压缩 模块来确定是否res.getHeader('Content-Type')可压缩。 0表示不使用压缩
app.use(favicon('./public/logo.png'));
//express 使用了静态资源托管文件
app.use('/dist', serve('./dist', true));
app.use('/public', serve('./public', true));
//这里给手机移动端用的，暂且保留这段代码
// app.use('/manifest.json', serve('./manifest.json', true))
app.use('/service-worker.js', serve('./dist/service-worker.js'));

// since this app has no user-specific content, every page is micro-cacheable.
//由于这个程序有没有用户特定的内容，每一页都是微缓存。
// if your app involves user-specific content, you need to implement custom
//如果应用程序涉及特定于用户的内容，则需要实现自定义。
// logic to determine whether a request is cacheable based on its url and
// headers.  逻辑判断一个请求可缓存基于URL和标题
// 1-second microcache.
// https://www.nginx.com/blog/benefits-of-microcaching-nginx/
// 使用了一秒的微缓存
/*
* 在大多数情况下，服务器渲染的应用程序依赖于外部数据，因此本质上页面内容是动态的，不能持续长时间缓存。
* 然而，如果内容不是用户特定(user-specific)（即对于相同的 URL，总是为所有用户渲染相同的内容），
* 我们可以利用名为 micro-caching 的缓存策略，来大幅度提高应用程序处理高流量的能力。
*
* 简单来说，就是某一个路由相同的界面，请求过的数据和界面，下一次将从缓存中拿取
* 目的旨在于提升服务器的响应速度
* */
app.use(microcache.cacheSeconds(1, req => useMicroCache && req.originalUrl))

function render (req, res) {
  const s = Date.now();

  res.setHeader("Content-Type", "text/html");
  res.setHeader("Server", serverInfo);

  const handleError = err => {
    if (err.url) {
      res.redirect(err.url)
    } else if(err.code === 404) {
      res.status(404).send('404 | Page Not Found')
    } else {
      // Render Error Page or Redirect
      res.status(500).send('500 | Internal Server Error')
      console.error(`error during render : ${req.url}`)
      console.error(err.stack)
    }
  }
  //应该在ssr之前把上下文所需的参数传进去
  const context = {
    // title: '未来淫如水', // default title  默认的标题
    url: req.url,
  };
  renderer.renderToString(context, (err, html) => {
    if (err) {
      return handleError(err)
    };
    // 在这里把界面发送给客户端

    // 之前处理head的方法，进行保留
    // res.send(parseMeta(html,context));
    res.send(html);
    if (!isProd) {
      console.log(`whole request: ${Date.now() - s}ms`);
    }
  })
}

app.get('*', isProd ? render : (req, res) => {
  readyPromise.then(() => render(req, res))
})

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`server started at localhost:${port}`);
})
